<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>GPS AR (Nearest Only + Enter/Leave Log)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- A-Frame & AR.js -->
  <script src="https://aframe.io/releases/1.4.1/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-ar.js@3.3.2/aframe-ar.min.js"></script>

  <style>
    body { margin: 0; overflow: hidden; }
    .hud {
      position: fixed; left: 10px; top: 10px;
      background: rgba(0,0,0,.5); color: #fff;
      padding: 8px 10px; border-radius: 6px;
      font: 14px/1.4 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "ヒラギノ角ゴ ProN", "Noto Sans JP", sans-serif;
      z-index: 10;
    }
  </style>
</head>

<body>
  <div class="hud" id="hud">lat: -, lon: -, ±- m</div>

  <a-scene
    vr-mode-ui="enabled: false"
    embedded
    renderer="antialias: true; colorManagement: true;"
    arjs="sourceType: webcam; gpsMinDistance: 1; debugUIEnabled: false;"
  >
    <a-camera gps-camera rotation-reader></a-camera>
  </a-scene>

  <script>
    // =========================
    // 設定
    // =========================

    // ◆ Enter/Leave ログ送信先（Google Apps Script などの WebApp URL）
    // 空文字のままなら送信しません
    const LOG_ENDPOINT = "https://script.google.com/macros/s/AKfycbzyjQtcf1Wam2KBCQQtrTj-HGmAglkiolEiOUxmB0d_LrtfKpO8AouweQ5Pc82_nFTRBw/exec"; // 例: "https://script.google.com/macros/s/XXXXX/exec"

    // ◆ カテゴリごとの色
    const CATEGORY_COLORS = {
      "観光":   "#f5a623", // オレンジ
      "公共":   "#0066cc", // ブルー
      "学校":   "#66cc66"  // グリーン
    };

    // ◆ 地点一覧（id, name, lat, lon, radius[m], category）
    const PLACES = [
      { id: 'tas-park',          name: 'タスパークホテル',          lat: 38.10148128126027, lon: 140.0433090680094, radius: 100, category: '観光' },
      { id: 'Marudaiougiya',     name: '丸大扇屋',                  lat: 38.11228246118919,  lon: 140.036198935986,   radius: 100, category: '観光' },
      { id: 'Kozakurakan',       name: '小桜館',                    lat: 38.110963329145335, lon: 140.03632275489852, radius: 100, category: '観光' },

      { id: 'MinamiNagai',       name: '南長井駅',                  lat: 38.09769549394771,  lon: 140.03458623775896, radius: 100, category: '公共' },
      { id: 'MichinoEkiNagai',   name: '道の駅 かわのみなと長井',  lat: 38.108970970886325, lon: 140.04382939078403, radius: 100, category: '公共' },
      { id: 'Nagaisiyakusho',    name: '長井市役所',                lat: 38.1063333593554,   lon: 140.033892868012,   radius: 100, category: '公共' },
      { id: 'Kurunt',            name: 'クルント',                  lat: 38.10491876278905,  lon: 140.03466346205656, radius: 100, category: '公共' },

      { id: 'NagaiKougyokoukou', name: '長井工業高校',              lat: 38.114426209437404, lon: 140.03013087985815, radius: 100, category: '学校' },
      { id: 'Nagaikoukou',       name: '長井高校',                  lat: 38.097283861825424, lon: 140.0380452392042,  radius: 100, category: '学校' }
    ];

    // =========================
    // ユーティリティ
    // =========================

    // Haversine 距離[m]
    function distanceMeter(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = d => d * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 +
                Math.cos(toRad(lat1))*Math.cos(toRad(lat2)) *
                Math.sin(dLon/2)**2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    // ログ送信（失敗しても黙って無視）
    async function sendLog(payload) {
      if (!LOG_ENDPOINT) return;
      try {
        await fetch(LOG_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
      } catch (_) {}
    }

    // =========================
    // エンティティ生成
    // =========================
    function createPlaceEntities() {
      const scene = document.querySelector("a-scene");

      PLACES.forEach(p => {
        const wrapper = document.createElement("a-entity");
        wrapper.setAttribute("id", "place-" + p.id);
        wrapper.setAttribute("gps-entity-place", `latitude: ${p.lat}; longitude: ${p.lon}`);
        wrapper.setAttribute("visible", "false");

        // ラベル
        const label = document.createElement("a-text");
        label.setAttribute("value", p.name);
        label.setAttribute("align", "center");
        label.setAttribute("color", "#ffffff");
        label.setAttribute("width", "6");
        label.setAttribute("position", "0 1.2 0");
        label.setAttribute("shader", "msdf");
        wrapper.appendChild(label);

        // マーカー（色はカテゴリで決定）
        const marker = document.createElement("a-sphere");
        marker.setAttribute("radius", "0.5");
        marker.setAttribute("color", CATEGORY_COLORS[p.category] || "#cccccc");
        marker.setAttribute("scale", "0.25 0.25 0.25");
        marker.setAttribute("animation", "property: rotation; to: 0 360 0; loop: true; dur: 6000; easing: linear");
        wrapper.appendChild(marker);

        scene.appendChild(wrapper);
      });
    }

    // =========================
    // 可視制御（最寄り1つだけ）
    // =========================
    let lastVisibleId = null; // いま見せている地点（Enter/Leave判定用）

    function updateVisibilityAndLog(lat, lon, acc) {
      // まず全非表示（重複防止のキモ）
      PLACES.forEach(p => {
        const ent = document.getElementById("place-" + p.id);
        if (ent) ent.setAttribute("visible", false);
      });

      // 範囲内の候補を距離でソート
      const candidates = PLACES
        .map(p => ({ ...p, dist: distanceMeter(lat, lon, p.lat, p.lon) }))
        .filter(p => p.dist <= p.radius)
        .sort((a,b) => a.dist - b.dist);

      const nearest = candidates[0] || null;

      // 表示切替
      if (nearest) {
        const ent = document.getElementById("place-" + nearest.id);
        if (ent) ent.setAttribute("visible", true);

        if (nearest.id !== lastVisibleId) {
          // Leave（前の地点）
          if (lastVisibleId) {
            const prev = PLACES.find(x => x.id === lastVisibleId);
            if (prev) {
              sendLog({
                type: "leave",
                placeId: prev.id, placeName: prev.name, category: prev.category,
                timestamp: Date.now()
              });
            }
          }
          // Enter（新しい地点）
          sendLog({
            type: "enter",
            placeId: nearest.id, placeName: nearest.name, category: nearest.category,
            distance: Math.round(nearest.dist),
            accuracy: acc,
            timestamp: Date.now()
          });

          lastVisibleId = nearest.id;
        }
      } else {
        // どこにもいない → 直前の地点をLeave
        if (lastVisibleId) {
          const prev = PLACES.find(x => x.id === lastVisibleId);
          if (prev) {
            sendLog({
              type: "leave",
              placeId: prev.id, placeName: prev.name, category: prev.category,
              timestamp: Date.now()
            });
          }
          lastVisibleId = null;
        }
      }
    }

    // =========================
    // 実行
    // =========================
    createPlaceEntities();

    const hud = document.getElementById("hud");

    if ("geolocation" in navigator) {
      navigator.geolocation.watchPosition(
        pos => {
          const { latitude:lat, longitude:lon, accuracy:acc } = pos.coords;
          hud.textContent = `lat: ${lat.toFixed(6)}\nlon: ${lon.toFixed(6)}\n±${Math.round(acc)} m`;
          updateVisibilityAndLog(lat, lon, Math.round(acc));
        },
        err => { hud.textContent = "位置取得エラー: " + err.message; },
        { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
      );
    } else {
      hud.textContent = "この端末では位置情報を利用できません。";
    }

    // ページ離脱時に Leave を補足送信（任意）
    window.addEventListener("beforeunload", () => {
      if (lastVisibleId) {
        const prev = PLACES.find(x => x.id === lastVisibleId);
        if (prev) {
          navigator.sendBeacon?.(LOG_ENDPOINT, JSON.stringify({
            type: "leave", placeId: prev.id, placeName: prev.name, category: prev.category, timestamp: Date.now()
          }));
        }
      }
    });
  </script>
</body>
</html>
